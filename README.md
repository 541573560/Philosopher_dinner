# 哲学家就餐问题
>问题描述

   哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。
哲学家从来不交谈，这就很危险，可能产生死锁，每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）。即使没有死锁，也有可能发生资源耗尽。例如，假设规定当哲学家等待另一只餐叉超过五分钟后就放下自己手里的那一只餐叉，并且再等五分钟后进行下一次尝试。这个策略消除了死锁（系统总会进入到下一个状态），但仍然有可能发生“活锁”。如果五位哲学家在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉。
>
### 我的解法
1.异步解法   
   异步解法将所有筷子聚到一起总共能够让2个人吃饭，吃完饭后所有筷子还给服务生。让另外的哲学家继续就餐
   主要方式是定义一个进程池，每当进程池中的进程吃完饭后再将进程赋予下一个哲学家吃饭
   
2.同步解法
  每次只允许一个哲学家就餐，当一个哲学家吃完饭后把叉子（进程）交给下一个哲学家使用
# Chandy/misra
> 算法描述
1.对每一对竞争一个资源的哲学家，新拿一个餐叉，给编号较低的哲学家。每只餐叉都是“干净的”或者“脏的”。最初，所有的餐叉都是脏的。
2.当一位哲学家要使用资源（也就是要吃东西）时，他必须从与他竞争的邻居那里得到。对每只他当前没有的餐叉，他都发送一个请求。
3.当拥有餐叉的哲学家收到请求时，如果餐叉是干净的，那么他继续留着，否则就擦干净并交出餐叉。
4.当某个哲学家吃东西后，他的餐叉就变脏了。如果另一个哲学家之前请求过其中的餐叉，那他就擦干净并交出餐叉。
>

### 实现
>我所想的数据结构如下   
* 哲学家 叉子 哲学家 叉子 哲学家 .....
* 类似于c语言中的结构体用python的类实现了
* 但是个人理解算法还不够深入，不知道何时开始哲学家的吃饭，有几个哲学家吃饭。  
* 之后可能会看一下网上有的这个算法java版本，然后在实现他
>
### 流程图如下
![da](https://img3.doubanio.com/view/photo/l/public/p2510347700.webp)

# 假脱机打印程序与虚拟设备
>描述
* 在网络环境下，连在网络服务器上的打印机要为多个终端服务，每个终端上的用户都可以通过客户端程序向服务器发送打印请求，服务器端的打印请求接收程序接收来自客户端的打印请求，并将该请求存放到磁盘上的打印请求队列中，由服务器端的假脱机打印程序在CPU空闲时从打印请求队列中取出请求信息，并将文件输出到打印机中。这种工作方式不是将文件直接输出到打印机，而是先将待打印的文件缓存到磁盘上，然后立即返回用户程序，从而缩短了用户响应时间，为用户提供了虚拟的快速打印机。
* 所以面对这种情况，我采用了多线程来模拟。真是情况下采用多线程比较适合i/o操作
>

#### 参考资料：
* [python多线程鸡肋嘛？](https://www.zhihu.com/question/23474039)
* [python多线程实现](http://python.jobbole.com/85050/)
* 操作系统课程设计指导书

#### 流程图
![算法流程图](https://img1.doubanio.com/view/photo/l/public/p2510349627.webp)

#### 难点
* 对于多线程来说，最大的特点就是线程之间可以共享数据，那么共享数据就会出现多线程同时更改一个变量，使用同样的资源，而出现死锁、数据错乱等情况。
* 假设有两个全局资源，a和b，有两个线程thread1，thread2. thread1占用a，想访问b，但此时thread2占用b，想访问a，两个线程都不释放此时拥有的资源，那么就会造成死锁。
* 对于该问题，出现了Lock。 当访问某个资源之前，用Lock.acquire()锁住资源,访问之后，用Lock.release()释放资源。
* 虽然Python多线程有缺陷，总被人说成是鸡肋，但也不是一无用处，它很适合用在IO密集型任务中。I/O密集型执行期间大部分是时间都用在I/O上，如数据库I/O，
* 较少时间用在CPU计算上。因此该应用场景可以使用Python多线程，当一个任务阻塞在IO操作上时，我们可以立即切换执行其他线程上执行其他IO操作请求。

> 从github克隆下来以后，理论上兼容python3.x。如果你的python版本为2.x注意input函数问题。然后在cmd上安装如下依赖包
```build
pip install Threding
pip install multiprocessing
pip inatall random
```

> 运行
```buildoutcfg
cd Philosopher_dinner
python Appear_deadlock.py
或者
python spool.py
```